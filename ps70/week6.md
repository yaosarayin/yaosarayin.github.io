# Electronic Input System

I got behind on work and ended up catching up on weeks 6 and 7 assignments together. I did week 7's assignment first and made the LED lights work. For this assignment, my goal was to combine the input system and control some outputs from the ESP32. When I started on the second half of this (photoresistor and LED), I had to switch my ESP32 board to WEMOS LOLIN32 because I fried my previous one.

It was a lot more work than anticipated to get my IR transistor to work with an IR LED. I was trying to measure the voltage generated by the voltage divider formed by the phototransistor and a certain resistor. I started out using 100â€“200 Ohm resistors, then 10 kOhm resistors, but I kept not seeing any voltage across the resistor. Finally, after asking for Nathan's help and changing to a 100 kOhm resistor, I started seeing voltage on the voltmeter. Oh well.

I need to review how the phototransistor works physically and why we need such a large resistor value.

<div style="display: flex; flex-wrap: wrap; align-items: center;">
    <div style="flex: 1; padding: 10px;">
        <img src="../img/week6/6-1.jpg" alt="">
    </div>
    <div style="flex: 1; padding: 10px;"> <p>
    My original plan was to build a remote control for my LED strip using IR LEDs and transistors. But I got frustrated with the transistor and wanted to try something where I knew the resistor values to use, so I decided to try a photoresistor circuit. This could make a touch-controlled light system.
    I measured the resistance across the photoresistor under ambient light in the lab, which was around 4.6 kOhm. When covered by my finger, the resistance across the two legs was about 30 kOhm. Great! This means I can choose a 10k resistor to connect to 5V, and the analog voltage output of the divider would be 1.7V in ambient classroom light and 3.7V under my finger. I can input this value into the ESP32 and control the LED lights accordingly.</p></div>

</div>

After some digging online (see [Random Nerd Tutorials](https://randomnerdtutorials.com/esp32-adc-analog-read-arduino-ide/)), I realized that for an ESP32, the analog inputs must be between 0 and 3.3V, so I needed to change my setup accordingly. When the 10k resistor is connected to the 3.3V supply, the voltage output of the divider goes between 1.1V in ambient room light and 2.5V when covered with a finger.

We need to carefully choose the pins that support ADC input. GPIO 4 is one of them. 

After connecting the photoresistor to the ESP32, I noticed that due to the extra wire, the resistance measured on the voltmeter somehow changed. I ran into a weird upload issue again (see my rant in week 7's notes). I figured out that I have to put the board in BOOT mode by connecting GPIO 0 to ground when uploading. But even when I successfully upload it once, the next time doesn't always work, which is very frustrating. I figured out that I really just need to unplug and replug the board every time before uploading and ensure that GPIO 0 is connected to ground during upload.

Finally, I got my code uploaded. I ran into issues where when I included functions to turn on the LED, the serial monitor didn't output anything. When it did show the `analogRead` values from the photoresistor, the values seemed to wobble around and didn't correlate with the light level.

<div style="display: flex; flex-wrap: wrap; align-items: center;">
    <div style="flex: 1; padding: 10px;">
        <img src="../img/week6/6-2.png" alt="6-2">
        <p>Setup with serial monitor.</p>
    </div>
</div>

After a bit of time and asking Bobby, I realized this wasn't because the LED interfered with the serial monitor but rather that my loop took a long time to run because I was running all the light sequences. The sensor reading had to wait for all the lights to finish running, then read and print again. The oscillating values were also because I was connected to the wrong pin. After correcting these issues, it worked. Silly me!

<div style="display: flex; flex-wrap: wrap; align-items: center;">
    <div style="flex: 1; padding: 10px;">
        <img src="../img/week6/6-3.png" alt="6-2">
        <p>Sensor output values.</p>
    </div>
</div>

In the image above, the two plateaus represent the sensor value with ambient light (raw value ~1120) and the sensor value when the resistor is covered by my finger (raw value ~3100). The voltages read from my voltmeter were 1.1V (ambient light) and 2.5V (finger covered). Now, we can devise a formula to convert voltage to raw ADC value and hopefully control the lights based on the sensor values.

And it's working! Yay! Now, my lights vary from red to green based on the sensor value.

<div style="display: flex; flex-wrap: wrap; align-items: center;">
    <div style="flex: 1; padding: 10px;">
        <video controls width="100%">
            <source src="../img/week6/6-1-MOV.mp4" type="video/mp4">
        </video>
    </div>
    <div style="flex: 1; padding: 10px;"><p> The problem now is how to make it pretty, integrate it with my little DJ box, and have music playing that syncs with the lights. But this board and the connections to the LED are finicky, and I might have accidentally broken the lights while playing with them more. I need to make better connectors. </p></div>
</div>



<div style="display: flex; flex-wrap: wrap; align-items: center;">
    <div style="flex: 1; padding: 10px;">
        <video controls width="100%">
            <source src="../img/week6/6-2-MOV.MOV" type="video/mp4">
        </video>
        <p>New working LED strip.</p>
    </div>
    <div style="flex: 1; padding: 10px;"> <p>In the end, I switched boards again to Seeed Studio's tiny ESP32-C3. However, I realized that it doesn't support the A2DP Bluetooth protocol anymore, so I had to remove that part. I need to look into how to do Bluetooth. </p></div>
</div>

**Code** (still with Bluetooth part):

<div class="code-block-wrapper">
<button class="copy-button" onclick="copyCode('example-code')">Copy</button>
<code id="example-code">

    #include "BluetoothA2DPSink.h"
    #include <Adafruit_NeoPixel.h>
    #ifdef __AVR__
    #include <avr/power.h> // Required for 16 MHz Adafruit Trinket
    #endif

    #define GREEN_LED 14 // Use GPIO 14 as LED pin
    #define WHITE_LED 13// Use GPIO 14 as LED pin
    #define sensorPin 4 // GPIO 4


    // Which pin on the Arduino is connected to the NeoPixels?
    #define LED_PIN  33
    // How many NeoPixels are attached to the Arduino?
    #define LED_COUNT 9

    Adafruit_NeoPixel strip(LED_COUNT, LED_PIN, NEO_GRB + NEO_KHZ800);
    BluetoothA2DPSink a2dp_sink;
    int sensorValue = 0;  // variable to store the value coming from the sensor
    int redValue = 0;
    int greenValue = 0;
    int blueValue = 0;

    int lowSensorVal = 1100;
    int highSensorVal = 3200;

    void setup() {
        Serial.begin(115200);
        pinMode(GREEN_LED, OUTPUT); // Initialize the LED pin as an output
        pinMode(WHITE_LED, OUTPUT); // Initialize the LED pin as an output
          // These lines are specifically to support the Adafruit Trinket 5V 16 MHz.
          // Any other board, you can remove this part (but no harm leaving it):
        #if defined(__AVR_ATtiny85__) && (F_CPU == 16000000)
          clock_prescale_set(clock_div_1);
        #endif
          // END of Trinket-specific code.

          strip.begin();           // INITIALIZE NeoPixel strip object (REQUIRED)
          strip.show();            // Turn OFF all pixels ASAP
          strip.setBrightness(50); // Set BRIGHTNESS to about 1/5 (max = 255)
        

        i2s_pin_config_t my_pin_config = {
            .mck_io_num = I2S_PIN_NO_CHANGE,    
            .bck_io_num = 27,
            .ws_io_num = 26,
            .data_out_num = 25,
            .data_in_num = I2S_PIN_NO_CHANGE
        };

        a2dp_sink.set_pin_config(my_pin_config);
        a2dp_sink.start("djbox");

        // In the setup function:
        a2dp_sink.set_stream_reader(audio_data_callback);


    }

    void loop() {

      sensorValue = analogRead(sensorPin);
      Serial.println(sensorValue);

      // Map the input value to RGB values
      redValue = map(sensorValue, lowSensorVal, highSensorVal, 255, 0);   // Example gradient: Red fades as the input increases
      greenValue = map(sensorValue, lowSensorVal, highSensorVal, 0, 255); // Green brightens as the input increases
      blueValue = map(sensorValue, lowSensorVal, highSensorVal, 0, 0);    // Blue stays constant (adjust as needed)

      // Fill along the length of the strip in various colors...
      // colorWipe(strip.Color(255,   0,   0), 50); // Red
      // colorWipe(strip.Color(  0, 255,   0), 50); // Green
      // colorWipe(strip.Color(  0,   0, 255), 50); // Blue
      // // Do a theater marquee effect in various colors...
      // theaterChase(strip.Color(127, 127, 127), 50); // White, half brightness
      // theaterChase(strip.Color(127,   0,   0), 50); //  Red, half brightness
      // theaterChase(strip.Color(  0,   0, 127), 50); // Blue, half brightness
      // rainbow(10);             // Flowing rainbow cycle along the whole strip
      // theaterChaseRainbow(50); // Rainbow-enhanced theaterChase variant

      colorWipe(strip.Color(redValue,   greenValue,   blueValue),0);
      delay(10);
    }

    volatile int16_t lastVolume = 0;

    void audio_data_callback(const uint8_t *data, uint32_t len) {
      //   int16_t *samples = (int16_t*) data;
    //   Serial.println(*samples);

        if (len >= 2048) { // Adjust based on your data packet size
            int32_t sum = 0;
            for (int i = 0; i < 1024; i += 4) { // Skip every other sample for simplicity
                int16_t sample = (int16_t)((data[i + 1] << 8) | data[i]);
                sum += abs(sample);
            }
            lastVolume = sum / 256; // Simplify by averaging volume
            // Serial.println(lastVolume);
              // Simple condition to turn LED on/off based on simulated volume
          if(lastVolume > 500) {
            Serial.println("light!");
            digitalWrite(GREEN_LED, HIGH); // Turn LED on
            colorWipe(strip.Color(255,   0,   0), 50); // Red
          } else if (lastVolume > 300){
            digitalWrite(WHITE_LED, HIGH); // Turn LED on
            rainbow(10);             // Flowing rainbow cycle along the whole strip
          } else {
            digitalWrite(GREEN_LED, LOW); // Turn LED off
            digitalWrite(WHITE_LED, LOW); // Turn LED off
          }

        }
    }


    // Fill strip pixels one after another with a color. Strip is NOT cleared
    // first; anything there will be covered pixel by pixel. Pass in color
    // (as a single 'packed' 32-bit value, which you can get by calling
    // strip.Color(red, green, blue) as shown in the loop() function above),
    // and a delay time (in milliseconds) between pixels.
    void colorWipe(uint32_t color, int wait) {
      for(int i=0; i<strip.numPixels(); i++) { // For each pixel in strip...
        strip.setPixelColor(i, color);         //  Set pixel's color (in RAM)
        strip.show();                          //  Update strip to match
        delay(wait);                           //  Pause for a moment
      }
    }


    // Theater-marquee-style chasing lights. Pass in a color (32-bit value,
    // a la strip.Color(r,g,b) as mentioned above), and a delay time (in ms)
    // between frames.
    void theaterChase(uint32_t color, int wait) {
      for(int a=0; a<10; a++) {  // Repeat 10 times...
        for(int b=0; b<3; b++) { //  'b' counts from 0 to 2...
          strip.clear();         //   Set all pixels in RAM to 0 (off)
          // 'c' counts up from 'b' to end of strip in steps of 3...
          for(int c=b; c<strip.numPixels(); c += 3) {
            strip.setPixelColor(c, color); // Set pixel 'c' to value 'color'
          }
          strip.show(); // Update strip with new contents
          delay(wait);  // Pause for a moment
        }
      }
    }

    // Rainbow cycle along whole strip. Pass delay time (in ms) between frames.
    void rainbow(int wait) {
      // Hue of first pixel runs 5 complete loops through the color wheel.
      // Color wheel has a range of 65536 but it's OK if we roll over, so
      // just count from 0 to 5*65536. Adding 256 to firstPixelHue each time
      // means we'll make 5*65536/256 = 1280 passes through this loop:
      for(long firstPixelHue = 0; firstPixelHue < 5*65536; firstPixelHue += 256) {
        // strip.rainbow() can take a single argument (first pixel hue) or
        // optionally a few extras: number of rainbow repetitions (default 1),
        // saturation and value (brightness) (both 0-255, similar to the
        // ColorHSV() function, default 255), and a true/false flag for whether
        // to apply gamma correction to provide 'truer' colors (default true).
        strip.rainbow(firstPixelHue);
        // Above line is equivalent to:
        // strip.rainbow(firstPixelHue, 1, 255, 255, true);
        strip.show(); // Update strip with new contents
        delay(wait);  // Pause for a moment
      }
    }


    // Rainbow-enhanced theater marquee. Pass delay time (in ms) between frames.
    void theaterChaseRainbow(int wait) {
      int firstPixelHue = 0;     // First pixel starts at red (hue 0)
      for(int a=0; a<30; a++) {  // Repeat 30 times...
        for(int b=0; b<3; b++) { //  'b' counts from 0 to 2...
          strip.clear();         //   Set all pixels in RAM to 0 (off)
          // 'c' counts up from 'b' to end of strip in increments of 3...
          for(int c=b; c<strip.numPixels(); c += 3) {
            // hue of pixel 'c' is offset by an amount to make one full
            // revolution of the color wheel (range 65536) along the length
            // of the strip (strip.numPixels() steps):
            int      hue   = firstPixelHue + c * 65536L / strip.numPixels();
            uint32_t color = strip.gamma32(strip.ColorHSV(hue)); // hue -> RGB
            strip.setPixelColor(c, color); // Set pixel 'c' to value 'color'
          }
          strip.show();                // Update strip with new contents
          delay(wait);                 // Pause for a moment
          firstPixelHue += 65536 / 90; // One cycle of color wheel over 90 frames
        }
      }
    }
</code>
</div>
</div>