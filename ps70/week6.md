# Electronic Input System

Okay so I got behind on work and ended up have to catch up on week 6-7's assignments together. I ended up doing Week 7's assignment first and making the LED lights work. So for this asignment's goal I want to combine the input system and control some outputs from ESP32. NOTE, when I started doing the second half of this (photoresister and LED) I also had to switch my ESP32 board (to WEMOS LOLIN32) because I fried my previous one. 

It was a lot more work than anticipated for me to get my silly little IR transister to work with an IR LED... I was probably also just not in my right mind that day... ANYWAYS, I was basically just trying to measure the voltage generated by the voltage divider formed by the phototrasnsiter and a certain resistor. I started out using 100-200 Ohm resisters and then 10 kOhm resisters but I kept not seeing any voltage across the resistor... Finally after asking for Nathan's help and changed to 100 kOhm resistor, I started seeing voltage on the voltmeter... Oh well.

I need to review how the phototransistor works physically and why we need such large of a resistor value.

<img src="../img/week6/6-1.jpg" alt=""> 

Okay so my original plan was to build a remote control for my LED strip using IR LEDs and transisters. But I got a bit mad about the transister and also I wanted to try something where I do know what resistor values to use as of now... SO I decided to try a photoresistor circuit - this can probably make a lil touch-controlled lights system.

I measured the resistance across the photo resistor under just ~ambient~ light in the lab: around 4.6 kOhn. When it is covered my finger, the resistance across the two legs is about 30 kOhm. Great! This means that I can choose a 10k resistor to connect to 5V, and the analog voltage output of the divider would be 1.7V in ambient classroom light and 3.7V under finger. I can input this value to the ESP32 and control the LED lights accordingly!

Then, after some digging online (https://randomnerdtutorials.com/esp32-adc-analog-read-arduino-ide/) I realized that for an ESP32 the analog inputs must be between 0 and 3.3V! Need to change my setup accordingly... So when the 10K resistor is connected to the 3.3 V supply, the voltage output of the divider goes between 1.1V at ambient room light and 2.5V when covered with finger.

We need to carefully choose the pins that support ADC input. GPIO 4 is one of them.

After connecting the photoresistor to the ESP32 I noticed that due to the extra wire the resistance measured on the voltmeter somehow changed

Running into wierd upload issue again... See my rant in week 7's notes. I figured out that I have to put the board in BOOT mode by connecting GPIO 0 to ground when uploading. But even when I successfully upload it once the next time doesn't seem to always work... very frustrating. I figured out that I really just need to unplug and replug the board everytime before uploading and make sure to connect GPIO0 to GND during upload...

Finally got my code uploaded. Ran into issues where when I include functions to turn the LED on the serial monitor doesn't output anything... When it does show the analogRead values from the photoresistor, the values seems to just wobble around and not correlate with how much light it is getting... 

<img src="../img/week6/6-2.png" alt="6-2"> 

After a hot minute and asking Bobby I realized that this is not because the LED interferes with the serial monitor, but rather that my loop just takes along time to run because I am running all the light sequences...So the sensor reading has to wait for all the lights to finish running then read and print again. And the oscillating values is just cuz I LITERALLY CONNECTED TO THE WRONG PIN...After correcting these, it works! Silly me!
 
<img src="../img/week6/6-3.png" alt="6-2"> 

In the image above, the two plateaus are the sensor value with ambient light (raw value ~ 1120) and the sensor value when the resistor is covered by my finger (raw value ~ 3100). The voltages as read from my voltmeter is 1.1V (ambient light) and 2.5V (finger covered). Now we can devise a formula to convert voltage to raw ADC value and hopefully control the lights based on the sensor values!

AAAAAND it's working! Yay! Now my lights varies from red to green based on the sensor value!!

<video controls>
  <source src="../img/week6/6-1-MOV.mp4" type="video/mp4">
</video>

The problem now is how to make it pretty and integrate it with my little DJ box and have music playing that sync with the lights :) But this board and the connections to the LED are all super finicky and I might have accidentally broke the lights while playing with it more... Need to make some better connectors...


In the end I ended up switching boards again to seed studio's tiny ESP32 C3. But I reaalized that it doesn't support A2DP bluetooth protocal anymore so I had to take that part out. Need to look more into how to do bluetooth...

<video controls>
  <source src="../img/week6/6-2-MOV.MOV" type="video/mp4">
</video>
New working LED strip (UP).

Code! (Still with bluetooth part)
```C
#include "BluetoothA2DPSink.h"
#include <Adafruit_NeoPixel.h>
#ifdef __AVR__
 #include <avr/power.h> // Required for 16 MHz Adafruit Trinket
#endif

#define GREEN_LED 14 // Use GPIO 14 as LED pin
#define WHITE_LED 13// Use GPIO 14 as LED pin
#define sensorPin 4 // GPIO 4


// Which pin on the Arduino is connected to the NeoPixels?
#define LED_PIN  33
// How many NeoPixels are attached to the Arduino?
#define LED_COUNT 9

Adafruit_NeoPixel strip(LED_COUNT, LED_PIN, NEO_GRB + NEO_KHZ800);
BluetoothA2DPSink a2dp_sink;
int sensorValue = 0;  // variable to store the value coming from the sensor
int redValue = 0;
int greenValue = 0;
int blueValue = 0;

int lowSensorVal = 1100;
int highSensorVal = 3200;

void setup() {
    Serial.begin(115200);
    pinMode(GREEN_LED, OUTPUT); // Initialize the LED pin as an output
    pinMode(WHITE_LED, OUTPUT); // Initialize the LED pin as an output
      // These lines are specifically to support the Adafruit Trinket 5V 16 MHz.
      // Any other board, you can remove this part (but no harm leaving it):
    #if defined(__AVR_ATtiny85__) && (F_CPU == 16000000)
      clock_prescale_set(clock_div_1);
    #endif
      // END of Trinket-specific code.

      strip.begin();           // INITIALIZE NeoPixel strip object (REQUIRED)
      strip.show();            // Turn OFF all pixels ASAP
      strip.setBrightness(50); // Set BRIGHTNESS to about 1/5 (max = 255)
    

    i2s_pin_config_t my_pin_config = {
        .mck_io_num = I2S_PIN_NO_CHANGE,    
        .bck_io_num = 27,
        .ws_io_num = 26,
        .data_out_num = 25,
        .data_in_num = I2S_PIN_NO_CHANGE
    };

    a2dp_sink.set_pin_config(my_pin_config);
    a2dp_sink.start("djbox");

    // In the setup function:
    a2dp_sink.set_stream_reader(audio_data_callback);


}

void loop() {

  sensorValue = analogRead(sensorPin);
  Serial.println(sensorValue);

  // Map the input value to RGB values
  redValue = map(sensorValue, lowSensorVal, highSensorVal, 255, 0);   // Example gradient: Red fades as the input increases
  greenValue = map(sensorValue, lowSensorVal, highSensorVal, 0, 255); // Green brightens as the input increases
  blueValue = map(sensorValue, lowSensorVal, highSensorVal, 0, 0);    // Blue stays constant (adjust as needed)

  // Fill along the length of the strip in various colors...
  // colorWipe(strip.Color(255,   0,   0), 50); // Red
  // colorWipe(strip.Color(  0, 255,   0), 50); // Green
  // colorWipe(strip.Color(  0,   0, 255), 50); // Blue
  // // Do a theater marquee effect in various colors...
  // theaterChase(strip.Color(127, 127, 127), 50); // White, half brightness
  // theaterChase(strip.Color(127,   0,   0), 50); //  Red, half brightness
  // theaterChase(strip.Color(  0,   0, 127), 50); // Blue, half brightness
  // rainbow(10);             // Flowing rainbow cycle along the whole strip
  // theaterChaseRainbow(50); // Rainbow-enhanced theaterChase variant

  colorWipe(strip.Color(redValue,   greenValue,   blueValue),0);
  delay(10);
}

volatile int16_t lastVolume = 0;

void audio_data_callback(const uint8_t *data, uint32_t len) {
  //   int16_t *samples = (int16_t*) data;
//   Serial.println(*samples);

    if (len >= 2048) { // Adjust based on your data packet size
        int32_t sum = 0;
        for (int i = 0; i < 1024; i += 4) { // Skip every other sample for simplicity
            int16_t sample = (int16_t)((data[i + 1] << 8) | data[i]);
            sum += abs(sample);
        }
        lastVolume = sum / 256; // Simplify by averaging volume
        // Serial.println(lastVolume);
          // Simple condition to turn LED on/off based on simulated volume
      if(lastVolume > 500) {
        Serial.println("light!");
        digitalWrite(GREEN_LED, HIGH); // Turn LED on
        colorWipe(strip.Color(255,   0,   0), 50); // Red
      } else if (lastVolume > 300){
        digitalWrite(WHITE_LED, HIGH); // Turn LED on
        rainbow(10);             // Flowing rainbow cycle along the whole strip
      } else {
        digitalWrite(GREEN_LED, LOW); // Turn LED off
        digitalWrite(WHITE_LED, LOW); // Turn LED off
      }

    }
}


// Fill strip pixels one after another with a color. Strip is NOT cleared
// first; anything there will be covered pixel by pixel. Pass in color
// (as a single 'packed' 32-bit value, which you can get by calling
// strip.Color(red, green, blue) as shown in the loop() function above),
// and a delay time (in milliseconds) between pixels.
void colorWipe(uint32_t color, int wait) {
  for(int i=0; i<strip.numPixels(); i++) { // For each pixel in strip...
    strip.setPixelColor(i, color);         //  Set pixel's color (in RAM)
    strip.show();                          //  Update strip to match
    delay(wait);                           //  Pause for a moment
  }
}


// Theater-marquee-style chasing lights. Pass in a color (32-bit value,
// a la strip.Color(r,g,b) as mentioned above), and a delay time (in ms)
// between frames.
void theaterChase(uint32_t color, int wait) {
  for(int a=0; a<10; a++) {  // Repeat 10 times...
    for(int b=0; b<3; b++) { //  'b' counts from 0 to 2...
      strip.clear();         //   Set all pixels in RAM to 0 (off)
      // 'c' counts up from 'b' to end of strip in steps of 3...
      for(int c=b; c<strip.numPixels(); c += 3) {
        strip.setPixelColor(c, color); // Set pixel 'c' to value 'color'
      }
      strip.show(); // Update strip with new contents
      delay(wait);  // Pause for a moment
    }
  }
}

// Rainbow cycle along whole strip. Pass delay time (in ms) between frames.
void rainbow(int wait) {
  // Hue of first pixel runs 5 complete loops through the color wheel.
  // Color wheel has a range of 65536 but it's OK if we roll over, so
  // just count from 0 to 5*65536. Adding 256 to firstPixelHue each time
  // means we'll make 5*65536/256 = 1280 passes through this loop:
  for(long firstPixelHue = 0; firstPixelHue < 5*65536; firstPixelHue += 256) {
    // strip.rainbow() can take a single argument (first pixel hue) or
    // optionally a few extras: number of rainbow repetitions (default 1),
    // saturation and value (brightness) (both 0-255, similar to the
    // ColorHSV() function, default 255), and a true/false flag for whether
    // to apply gamma correction to provide 'truer' colors (default true).
    strip.rainbow(firstPixelHue);
    // Above line is equivalent to:
    // strip.rainbow(firstPixelHue, 1, 255, 255, true);
    strip.show(); // Update strip with new contents
    delay(wait);  // Pause for a moment
  }
}


// Rainbow-enhanced theater marquee. Pass delay time (in ms) between frames.
void theaterChaseRainbow(int wait) {
  int firstPixelHue = 0;     // First pixel starts at red (hue 0)
  for(int a=0; a<30; a++) {  // Repeat 30 times...
    for(int b=0; b<3; b++) { //  'b' counts from 0 to 2...
      strip.clear();         //   Set all pixels in RAM to 0 (off)
      // 'c' counts up from 'b' to end of strip in increments of 3...
      for(int c=b; c<strip.numPixels(); c += 3) {
        // hue of pixel 'c' is offset by an amount to make one full
        // revolution of the color wheel (range 65536) along the length
        // of the strip (strip.numPixels() steps):
        int      hue   = firstPixelHue + c * 65536L / strip.numPixels();
        uint32_t color = strip.gamma32(strip.ColorHSV(hue)); // hue -> RGB
        strip.setPixelColor(c, color); // Set pixel 'c' to value 'color'
      }
      strip.show();                // Update strip with new contents
      delay(wait);                 // Pause for a moment
      firstPixelHue += 65536 / 90; // One cycle of color wheel over 90 frames
    }
  }
}

```